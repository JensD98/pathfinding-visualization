\part{Programming Principles} \label{part:programming-principles}
Es wurde versucht, während der Entwicklung
verschiedene \textit{programming principles} einzuhalten.
Vor allem das Erreichen von geringer Kopplung ist mit
ASP.NET Core eine leichte Aufgabe.
Die Funktionsweise von Klassen sollte durch Interfaces beschrieben werden.
Durch den bereits standardmäßig vorhandenen \acl{di} \textit{container} (\acs{di}-Container)
können diese Interfaces der gesamten Anwendung zur Verfügung gestellt werden.
Im Fall von einer Änderung kann so ein Austausch der
Implementierung mit minimalem Aufwand (eine Zeile) erfolgen.
Eine geringe Kopplung wird nach diesem Prinzip erreicht.
SOLID und DRY Prinzipien sollten auf Seiten des API Projekts ebenfalls umgesetzt sein.
Das Verwenden von \acs{di} hilft auch in diesen Bereichen Verstößen vorzubeugen.
Ein Beispiel kann gegeben werden für das \textbf{L} (Liskov Substitution Principle)
in SO\textbf{L}ID. Die umgesetzten Wegfinde-Algorithmen benötigen eine
Funktion, welche von einem gegebenen Knoten aus die nächsten zu besuchenden
Knoten auswählt. Die Methode wird \inlinecode[\colorMethods]{GetNeighbors}
genannt und ist definiert in der abstrakten Klasse \inlinecode[\colorClasses]{Grid},
wie im folgenden Programmausschnitt zu sehen ist.

\begin{lstlisting}[caption={\textbf{Grid} Entität},label={code:grid-entity}]
public abstract class Grid
{
    public abstract List<GridNode> GetNeighbors(GridNode node);
}
\end{lstlisting}
Subklassen, die von \inlinecode[\colorClasses]{Grid} ableiten, müssen diese Methode überschreiben.
Für den Algorithmus spielt es keine Rolle, wie die konkrete Umsetzung aussieht.
Zum Beispiel könnte eine Implementierung die horizontal liegenden Nachbarn liefern,
eine andere die diagonal liegenden und eine weitere beide. Der Algorithmus bleibt
bei einem Austausch gleich. Ähnliches Verhalten kann
beobachtet werden, wenn es um die Wegfinde-Verfahren selbst geht.
Jede Wegfinde-Klasse besitzt eine Methode \inlinecode[\colorMethods]{ShortestPath}
und muss das folgende Interface implementieren.
\begin{lstlisting}[caption={Wegfinde-Algorithmus Interface},label={code:i-pathfinding}]
public interface IPathfindingAlgorithm
{
    PathfindingResult ShortestPath();
}
\end{lstlisting}
Eine weitere Klasse, die Wegfinde-Funktionalität benötigt, ist dadurch nicht abhängig
von einer bestimmten Implementierung. Die beiden letzten Zeilen
in \autoref{code:pathfinding-abstracttion} sind äquivalent.
\newpage
\begin{lstlisting}[caption={Abstraktion der Wegfinde-Algorithmen},
label={code:pathfinding-abstracttion}]
Grid grid = new Subklasse();
IPathfindingAlgorithm bfs = new BreadthFirstSearch(grid);
IPathfindingAlgorithm dijkstra = new Dijkstra(grid);
\end{lstlisting}